Основная логика GC реализована тут: src/runtime/mgc.go

GC реализован с помощью алгоритма Mark and Sweep
Mark - фаза разметки
    - реализована с помощью трехцветного алгоритма. Он конкурентный и выполняется
    конкурентно с основной программой, которая называется мутатором. Мутатор -
    потому что изменяет состояние кучи
        - все данные в куче представляются как граф связанных объектов
        - каждый объект может быть окрашен в один из трех цветов: белый, серый, черный
        - обходятся корневые объекты: глобальные переменные
        - далее эти элементы проверяются на наличие указателей на них: если указатель есть,
        они помечаются черным, если нет - белым. Серые - это те, на которые есть указатель,
        но пока еще не понятно откуда. В итоге серые и черные остаются, а белые удаляются.

Sweep - фаза очистки

Другие сущности GC:
 - Write barrier - следит за тем, чтобы черные объекты не указывали на белые.
Наша программа полностью останавливается на какое-то мгновение, чтобы
включился Write barrier. Он включается на фазе разметки.
 - Pacer - следит за размером памяти. Как только размер кучи в 2 раза превысил
 исходный размер, вызывается GC. Этот коэффициент "2 раза" можно регулировать с
 помощью переменной окружения GOGC

 - GC можно вызывать вручную с помощью с помощью функции runtime.GC()
 - на работу GC выделяется 25% CPU