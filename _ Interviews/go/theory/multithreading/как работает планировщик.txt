Источник: https://www.youtube.com/watch?v=rloqQY9CT8I

— Логика работы планировщика описана в файле: src/runtime/proc.go
— В планировщике Go участвуют три ключевые сущности:

  ● P — логический процессор (не физическое ядро). Это абстрактный контекст
  выполнения, который объединяет:
      – очередь горутин (runqueue),
      – и поток ОС (M), который может быть к нему привязан.
    Каждый P управляет своей очередью горутин.
    Количество доступных P определяется через переменную окружения `GOMAXPROCS`
    и по умолчанию равно количеству логических ядер.

  ● M — поток операционной системы (OS thread).
    Один M может быть связан с одним P. Если горутина выполняет системный вызов и
    блокирует поток, планировщик может выделить новый M, чтобы другие P не простаивали.

  ● G — горутина (Go routine), легковесная задача, планируемая внутри рантайма Go.

— Связь между M и P:
    – Один P может быть привязан к одному M одновременно.
    – M может быть переназначен от одного P к другому, если это нужно для балансировки.

— Планировщик Go использует **вытесняющую многозадачность**:
— Планировщик использует **очереди FIFO** (First-In-First-Out) для горутин внутри P.
— Планировщик реализует стратегию "воровства работы" (work stealing):
    – Если у одного P нет задач, он может "украсть" горутины из очереди другого P,
      чтобы не простаивать и равномерно распределять нагрузку по ядрам.

— Планировщик **неинвазивный**:
    – Он **не прерывает** длительно работающую горутину (например, при вычислениях
    в бесконечном цикле), если она не делает syscall или не вызывает функции, в
    которых встроены yield-точки.

— Планировщик **не использует приоритеты**:
    – Все горутины обрабатываются **на равных**, в порядке поступления (FIFO),
      без гарантий точного времени исполнения.
