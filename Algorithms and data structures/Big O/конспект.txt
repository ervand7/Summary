 ● main article
https://stackabuse.com/big-o-notation-and-algorithm-analysis-with-python-examples/

 ● main video
https://www.youtube.com/watch?v=ZRdOb4yR0kk

 ● other important videos:
https://www.youtube.com/watch?v=kwmQwGbAh28
https://www.youtube.com/watch?v=eJRg4qr7qAo&list=LL&index=2
https://www.youtube.com/watch?v=mgvbBU4bMF8&list=LL&index=3&t=168s
https://www.youtube.com/watch?v=72jqTtfw2z4&list=LL&index=1
___________________________________________________________________________________________


 ● O(1)
когда у нас гарантировано одно действие. Например:
 - получить значение по ключу в хеш-таблице
 - найти индекс у сортированного элемента

 ● O(log n)
при использовании бинарного поиска по сортированному контейнеру (ищем по принципу двоичного дерева)

 ● O(n)
 - когда сложность растет в линейном порядке параллельно с увеличением входных параметров
 - когда мы имеем 2 подряд идущих невложенных зависимых цикла: O(n + n) = O(n)

 ● O(n + other)
 - когда идут 2 подряд независимых друг от друга цикла

 ● O(n * other)
 - когда внешний цикл длиной n, а внутренний цикл длинной other

 ● O(n * log(n))
 - при использовании бинарного поиска по несортированному контейнеру (ищем по принципу двоичного дерева)

 ● O(n^2)
 - при вложенных циклах
 - при ситуациях, где изначально при запуске и внешнего, и вложенного
циклов длины n внешнего и n внутреннего равны, а затем одна из них сокращается,
скажем, в 2 раза: O(n^2 / 2) ≈ O(n^2)

 ● O(n!)
Факториальная сложность
 - задача о коммивояжере

___________________________________________________________________________________________
Принципы Big O:
 ● Big O показывает темп роста функции. Следовательно, мы не учитываем константы и неважную сложность
 ● Последовательность действий - сложение. Вложенные действия - умножение
 ● Для алгоритма, где на каждой итерации берется половина элементов сложность
будет включать O(log n) или O(n * log(n))