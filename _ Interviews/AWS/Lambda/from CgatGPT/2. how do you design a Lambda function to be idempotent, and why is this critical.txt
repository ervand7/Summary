Idempotency means: the same event processed multiple times produces the same result.

Why itâ€™s critical in Lambda:

* Lambda + event sources can retry on failures/timeouts
* Messages can be delivered more than once (at-least-once delivery)
* Without idempotency you get double charges, duplicate rows, repeated emails, etc.

How to design it:

1) Pick an idempotency key
   * Use event_id / message_id (SQS), request_id, or a hash of the payload
   * Must uniquely represent â€œthis operationâ€

2) Store â€œseenâ€ keys in durable storage with TTL
   * DynamoDB is the classic choice
   * Key = idempotency_key, value = status + response + expires_at

3) Use conditional writes / transactions
   * First writer wins (PutItem with ConditionExpression attribute_not_exists)
   * If key already exists â†’ return stored result or â€œalready processedâ€

4) Make downstream writes idempotent too
   * Use UPSERT patterns (DynamoDB UpdateItem, SQL ON CONFLICT)
   * Use stable primary keys derived from the idempotency key
   * Ensure side effects (email/payment) have their own idempotency key

5) Handle â€œin-progressâ€ vs â€œdoneâ€
   * Store status = IN_PROGRESS then DONE
   * Prevent two Lambdas from doing the work concurrently

Interview answer to â€œHow do you make Lambda idempotent?â€

> I assume retries and duplicates, so I use a stable idempotency key per request,
store it in DynamoDB with a conditional write, and return the stored result on repeats.
This prevents duplicate side effects like double payments or duplicate records.

ğŸ‘‰ Think: `retries are normal â€” duplicates must be harmless`.
