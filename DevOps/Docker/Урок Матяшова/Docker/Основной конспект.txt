ИСТОЧНИК:
https://www.youtube.com/watch?v=QF4ZF857m44&fbclid=IwAR2IXGKI4P9tx_lNnus0_YdPlcxmWZF2PtoJ8VTeppMmbZO4krrozp1ADGA
__________________________________________________________________________________________________________________

УСТАНОВКА:
 ● Устанавливаем Docker https://www.docker.com/products/docker-desktop
 ● Скачиваем, если у нас нет, плагин Docker в PyCharm, чтобы PyCharm понимал, что такое Dockerfile
__________________________________________________________________________________________________________________

ОПРЕДЕЛЕНИЯ:
1) Docker - это средство упаковки, доставки и запука приложений.

2) Docker image (образ) - то, что мы запаковали, то есть готовое, но еще не запущенное приложение.
Имеджи представляют собой многослойную систему, в которой мы можем накладывать слои друг на друга.

3) Docker registry (реестр имеджей) - находится у нас локально. Там находятся образы (имеджи), которые создали именно мы. Но мы
же не будем создавать все имеджы, если есть уже где-то готовые. Готовые находятся в Docker hub.

4) Docker hub - это реестр с имеджами, где есть имеджи, которые поддерживаются разработчиками докера, а есть имеджи, которые
пишут сами люди, которые там регистрируются. Мы также можем пушить свои имеджи в Docker hub и оттуда уже брать их на продакшн.

5) Контейнер - это работающее приложение, созданное на базе image.


==============================================================================================================
==============================================================================================================
==============================================================================================================
==================================== создадим и запакуем приложение app.py ===================================
 ● Создаем приложение (просто обычный .py файл) и назовем его "app.py"
 ● Создаем Dockerfile, иначе будет ошибка: unable to prepare context unable to evaluate symlinks in Dockerfile path.
Этого Dockerfile в данном репозитории нет, но мы пропишем содержимое Dockerfile:
FROM python:3.8                FROM - это базовый образ, с которого мы начинаем сборку

RUN mkdir -p /usr/src/app      RUN означает выполнить какую-то определенную команду. В данном случае создать папку

WORKDIR /usr/src/app           WORKDIR - это просто переход в созданную папку

COPY . /usr/src/app            COPY - копирование. Принимает 2 аргумента: откуда и куда. В данном примере говорит, что
с нашей текущей директории нужно скопировать в контейнер (созданную папку)

CMD ["python", "app.py"]       CMD - это команда, которая говорит, что нужно делать, когда мы запустим контейнер.
В данном случае нужно выполнить 2 команды.
Примечание: здесь мы могли вместо CMD написать ENTRYPOINT (в отличии от CMD выполняет команду без shell-оболочки)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
КОМАНДЫ:
 ● docker images                              смотрим, какие images есть

 ● docker ps                                  смотрим, какие контейнеры есть

 ● docker build -t hello-world .              собираем образ, пакуем наше приложение в Docker и смотрим, как выглядят образы.
Команда <docker build> создает образы. Флаг -t означает тег, как мы назовем наш новый образ. Назовем его
<hello-world>. Следующим параметром мы должны указать исходник, то есть путь, откуда мы все будем собирать.
В данном случае ставим "." - что обозначает текущую директорию.
Что тут произошло? Мы видим загрузку базового образа, который мы указали в Dockerfile (FROM python:3.8). Докер
не нашел такой образ локально, он пошел в Docker hub, нашел там такой образ и начал его скачивать

 ● docker build -- no-cache -t hello-world .  перестраивает имедж без использования кэша, поэтому это, по сути, чистая сборка

 ● docker run hello-world                     запускаем приложение (контейнер) командой: docker run <название образа>

 ● docker ps                                  контейнер работает до тех пор, пока работает приложение. Так что, если сейчас
запустим команду <docker ps>, то, к удивлению увидим, что он пуст

 ● docker ps -a                               поэтому используем команду <docker ps -a>, чтобы посмотреть все контейнеры, даже те, которые остановились

 ● docker run --name ervand hello-world       задаем имя контейнеру. Если имя не задать, то docker будет подставлять какие-то рандомные имена

 ● docker rm fd6322680fe1                     удаляем контейнер по айдишнику
или
 ● docker rm ervand                           удаляем контейнер по имени контейнера (не путать с именем образа!)

 ● docker ps -a -q                            этой командой docker нам возвращает только айдишники контейнеров

 ● docker rm $(docker ps -qa)                 удаляем все контейнеры за 1 раз

 ● docker build -t hello-world .              соберем обновленный docker image. Обратите внимание, что в этот раз не происходит
 скачивание базового образа python 3.8, так как он уже есть в нашем локальном хранилище

 ● docker run --name ervand2 -d hello-world   аргумент -d означает, что наш контейнер будет работать в фоне. Перед
запуском этой команды мы для эксперимента в нашем приложении запустили бесконечный цикл. Поэтому мы используем флаг -d,
чтобы наш контейнер работал в фоне. Ибо, если запустить терминал без него, терминал навечно будет занят. Обратите внимание,
в этот раз мы назвали наш контейнер как "ervand2"

 ● docker stop ervand2                        останавливаем контейнер по имени контейнера (не путать с именем образа!)
или
 ● docker stop <айдишник контейнера>          останавливаем контейнер по айдишнику

 ● docker run --name ervand2 -d --rm hello-world    так мы запустим контейнер с условием его автоудаления либо по окончанию
работы, либо когда его остановят принудительно


================================================================================================================
================================================================================================================
================================================================================================================
==================================== создадим и запакуем приложение app2.py ====================================
Это веб приложение на основе Flask. Суть приложения: когда мы в браузере открываем страницу, у нас открывается файл
"response.json", оттуда достается содержимое поля "payload", добавляется текущая дата и это все возвращается пользователю
как строка.
Попробуем запаковать это приложение в Docker.
Внимание! Содержимое Dockerfile измененно уже конкретно под это приложение. Содержимое для первого приложения
"app.py" представлено выше (смотри строки 29-40).

 ● docker build -t qwerty .                      соберем наш новый docker образ (image). Даем на этот раз псевдоним "qwerty"

 ● docker run --rm --name ervand3 -p 8080:8080 -e TZ=Europe/Moscow qwerty
Запускаем. Обратите внимание, что возможна другая последовательность флагов.
Флаг <-p> указывает на порт (который мы прописали в Dockerfile). Через двоеточие указываем 2 порта.
Первый будет на нашей машине, второй - порт внутри docker-контейнера. Если мы явно не укажем, что порт из контейнера
пробрасывается в в наружный порт, то ничего не произойдет. Ну а <-e TZ=Europe/Moscow> заменяет то, то мы закомментировали
в Dockerfile как ENV TZ Europe/Moscow. Также обратите внимание, что на этот раз мы называем контейнер как "ervand3".

 ● control+C                                     останавливаем контейнер

____________________________________________________________________________________________________________
МОНТИРОВАНИЕ ДАННЫХ К КОНТЕЙНЕРУ:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 1 СПОСОБ: через флаг <-v> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Как это делается:
1) пишем флаг -v
2) прописываем абсолютный путь к папке, которую мы хотим прикрепить к контейнеру
3) сразу ставим двоеточие
4) сразу прописываем абсолютный путь к папке внутри контейнера.


 ● cd resources/                                 предварительно заходим в папку "resources"
 ● pwd                                           узнаем, какой у этой папки абсолютный путь и копируем его. Это будет наш 1й путь.
 ● заходим в Dockerfile и копируем </usr/src/app2>, это находится в колонке COPY. Это будет наш 2й путь.
 ● прилепляем вконце через слеш название папки resources, в которой у нас находится информация для вывода на экран.

Вот результат:
 ● docker run --rm --name ervand3 -p 8080:8080 -e TZ=Europe/Moscow -v /Users/USER/Desktop/Python/My_best_summary_about_python/summary/Docker/resources:/usr/src/app2/resources qwerty

Что изменилось? Теперь мы имеем возможность монировать локальные папки в docker-контейнер. И теперь, если мы
останавливаем контейнер, сам файлик остается и не исчезает.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 2 СПОСОБ: через флаг <-v> + volume ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Docker volume - это папка, примонтированная к контейнеру. Для чего это актуально?
1) Для баз данных. Мы можем указать путь, где базы данных будут сохранять информацию. И при остановке контейнера
с инфо ничего не случится, потому что она хранится в volume. И далее мы уже можем этот volume привязать к другому контейнеру.
2) Для файловых серверов.

 ● docker volume ls                              смотрим, какие volume у нас есть, и видим, что никаких нет
 ● docker volume create web                      создаем docker volume и даем ему имя "web"

 ● docker run --rm --name ervand3 -p 8080:8080 -v web:/usr/src/app2/resources qwerty
Где:
1) <docker run> - команда запуска
2) <--rm> - флаг, который говорит, что будет автоудаление контейнера по окончанию его работы
3) <--name ervand3> - название нашего контейнера
4) <-p 8080:8080> - порты
5) <-v> - флаг, который мы прописываем для указания пути
6) <web> - название нашего volume. Обратите внимание, что в <1 СПОСОБ> мы указывали на этом месте абсолютный путь к
файду, который мы хотим прикрепить к контейнеру. Сейчас же на этом месте мы прописываем название нашего volume
7) <:> - обязательное двоеточие
8) </usr/src/app2/resources> - абсолютный путь к контейнеру
9) <qwerty> - имя нашего docker image

И теперь вся информация, которая хранится по пути <web:/usr/src/app2/resources>, будет храниться в docker volume.

================================================================================================================
================================================================================================================
================================================================================================================
==================================== создадим и запакуем приложение  app3.py ===================================
Мы разрабатываем приложение, которое работает с БД и нам нужно временно развернуть эту БД, чтобы потом, протестировав что-то
удалить ее. Сейчас в при запуске команды <docker image> мы видим, что у нас локально нет mongo. Но мы знаем, что mongo у нас есть
в docker hub. И мы хотим запустить контейнер на базе с образом mongo.

 ● docker run -d --rm -p 27017:27017 mongo     запускаем контейнер на базе с образом mongo. Опять же, этот образ mongo
мы не создаем, он берется с Docker hub. Соответственно ут терминал сам нам говорит, что локально mongo не
нашлась (Unable to find image 'mongo:latest' locally), но нашлась в docker hub. И идет скачивание.

 ● запускаем наше приложение и видим, что вывелись 5 объектов

 ● запускаем наше приложение еще раз и видим, что уже вывелись 10 объектов

Теперь, скажем, мы создали какое-то дополнительное поле в бд, и у нас появилась необходимость зачистить базу, так как
модель, которая находится в этой базе уже не соответствует нашим требованиям.
Мы это делаем следующим образом:
 ● docker ps                                     смотрим, какие контейнеры у нас запущены

 ● docker stop 54245788f820                      останавливаем контейнер по его айдишнику

 ● docker run -d --rm -p 27017:27017 mongo       запускаем новый контейнер

 ● запускаем наше приложение и видим, что там все началось по новой, и появилось наше новое поле

 ● docker rmi mongo                              удалим image локально по имени образа (не путать с именем контейнера!)
 или
 ● docker rmi <айдишник образа>                  удалим image локально по айдишнику образа

 ● docker images -q                              увидим все айдишники

 ● docker rmi $(docker images -q)                удалим все images по списку айдишников имеджей

В результате нам не пришлось устанавливать mongo, конфигурировть ее. Докер сам все сделал со своего Docker hub.
Обратите внимание, из-за того что мы несколько раз создавали образ с одним и тем же тегом, у нас появились <none> имеджи,
которые мы затем удалили со всеми другими имеджами командой <docker rmi $(docker images -q)>

+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_
+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_
ИТОГ:
У нас есть имейджи, на основе которых создаются контейнеры. Контейнеров может быть много. Контейнеры полностью
изолированы. Мы можем в них открыть порты, приделать к ним волюмы (для хранения каких-то данных). Контейнеры могут быть
запущенными, остановленными, удаленными. У нас есть docker hub, где хранятся какие-то образы, которые мы можем забирать.
Там есть готовые образы, типа mongo, python. Мы можем пробрасывать переменные в контейнер посредством запуска команды -e, либо
дописывая Dockerfule. Мы узнали, как можно создавать временные БД и тестировать их.
+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_
+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_
================================================================================================================
================================================================================================================
================================================================================================================
Docker compose - это специальная надстройка над докером. Если нам требуется запустить множество приложений, то
для того, чтобы нам не пришлось совершать много действий, мы все оформляем в один файл и говорим, чтобы Docker compose
запустил его.
Если в проекте используется Docker compose, то всегда должен быть конфинурационный файл <docker-compose.yml>
