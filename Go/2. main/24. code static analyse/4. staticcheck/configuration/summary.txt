staticcheck ищет staticcheck.conf в директории анализируемого файла,
потом выше, в родительской директории, и так до корня проекта. Читаются все
найденные конфигурационные файлы. Опции из найденных файлов объединяются.
В случае конфликтов предпочтение отдаётся установкам, сделанным в тех
конфигурационных файлах, которые расположены «ближе» к объекту анализа.
Это позволяет создавать общую конфигурацию для всего проекта и частные для ветвей.

В этом примере:
 - checks — содержит список подключённых и отключённых правил.
 - initialisms — определяет список известных сокращений для правила ST1003.
 - dot_import_whitelist — позволяет задать белый список путей импорта для тех
пакетов, которые можно точечно импортировать куда угодно. Хотя по умолчанию
правило ST1001 запрещает любое использование точечного импорта в нетестовых пакетах.
 - http_status_code_whitelist — задаёт список исключений, которые будет пропускать
проверка ST1013. Правило ST1013 рекомендует использовать константы
из пакета net/http вместо жёсткого кодирования числовых кодов состояния HTTP.

Конфигурационный файл staticcheck.conf может быть определён в каждой
поддиректории. Если параметр не определён, то он наследуется от файла
конфигурации высшего уровня. В противном случае параметр настройки переопределяется.

Проверки в исходном коде можно отключать, используя директиву
//lint:ignore Check1[,Check2,...,CheckN] reason. Тогда проверка будет
отключена для следующей строки.
func TestNewErrorEqual(t *testing.T) {
    //lint:ignore SA4000 параметр одинаковый, но результат должен быть разный
    if errors.New("test") == errors.New("test") {
        t.Errorf(`New("test") == New("test")`)
    }
}

Если требуется отключить проверку для всего файла, нужно в начале файла указать
директиву //lint:file-ignore Check1[,Check2,...,CheckN] reason:
package main
//lint:file-ignore U1000 игнорируем неиспользуемый код, так как он сгенерирован