Goal: keep secrets out of code, limit access, and rotate safely.

Configuration vs secrets:

* Config (non-sensitive): feature flags, URLs, timeouts
* Secrets (sensitive): passwords, API keys, private tokens

Environment variables:

* Good for non-secret config (simple + fast)
* If used for secrets:
  - encrypt with KMS (Lambda env var encryption)
  - restrict IAM so only the function role can decrypt
  - still avoid storing long-lived secrets there if rotation matters

SSM Parameter Store:

* Best for:
  - non-secret config (String)
  - secrets with basic needs (SecureString)
* Pros: cheap, simple, hierarchy (/prod/app/key)
* Use KMS for SecureString and least-privilege IAM
* Cache values in-memory to reduce API calls

Secrets Manager:

* Best for:
  - true secrets that need rotation (DB creds, third-party API keys)
  - integration with RDS rotation
* Pros: built-in rotation + secret versioning
* Cons: cost higher than SSM
* Fetch at init and cache with TTL; handle rotation by refetching on expiry/failure

Security best practices:

* Least-privilege IAM (only specific parameter/secret ARNs)
* Separate secrets per env (dev/stage/prod)
* Use VPC endpoints for SSM/Secrets Manager if in VPC to avoid public internet
* Donâ€™t log secrets; redact logs
* Prefer short-lived creds where possible (IAM roles, STS)

Interview answer to â€œHow do you handle config and secrets in Lambda?â€

> I put non-sensitive config in env vars, store sensitive values in SSM SecureString
or Secrets Manager, and restrict access via least-privilege IAM + KMS. I typically
load secrets at cold start and cache them with a TTL, and use Secrets Manager when
rotation is required.

ðŸ‘‰ Think: `env for config`, `SSM for parameters`, `Secrets Manager for rotating secrets`.
