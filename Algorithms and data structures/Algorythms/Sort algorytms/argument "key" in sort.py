# Аргумент key в сортировке
# 1) Передача встроенной функции
a = [4, -10, 43, -300, 54, 289, -34, -8, 749]
print(sorted(a, key=abs))  # [4, -8, -10, -34, 43, 54, 289, -300, 749]


# 2) Передача собственной функции
# Напишем функцию, которая сортирует все по последней цифре
def f(x):
    return x % 10  # или -(x%10) чтобы выполнить сортировку в обратном порядке
    # либо мы можем задать такое условие:
    # return x%10, x//10%10 # тут в x//10%10 мы избавляемся от текущей последней цифры, а затем
    # берем оставшуюся последнюю цифру и по ней сортируем все элементы списка. То есть, сперва все цифры
    # сортируются по последней цифре (x%10). И, если эти последние цифры равны, то в этот момент вступает
    # в действие второй признак нашей сортировки (x//10%10 )


b = [4, 10, 43, 300, 54, 289, 34, 8, 749]
print(sorted(b, key=f))  # [10, 300, 43, 4, 54, 34, 8, 289, 749]

# 3) Передача встроенных методов объектов
c = ['ZZZ', 'aaa', 'eee', 'DDD', 'BBB', 'www']
print(sorted(c, key=str.lower))  # ['aaa', 'BBB', 'DDD', 'eee', 'www', 'ZZZ']

# 4) Передача анонимных функций
d = ['ZZZ 1', 'aaa 32', 'eee 356', 'DDD 88', 'BBB 38', 'www 99']
print(sorted(d, key=lambda x: int(x.split()[1])))
# ['ZZZ 1', 'aaa 32', 'BBB 38', 'DDD 88', 'www 99', 'eee 356']

# Теперь зададим несколько параметров для сортировки, чтобы, если цифры совпадают, у нас эти элементы
# сортировались по алфавиту. Поскольку анонимная функция может вернуть нам тольк одно значение, мы
# дополнительно оборачиваем int(x.split()[1] и x.split()[0] в единый кортеж (int(x.split()[1]), x.split()[0])
e = ['ZZZ 32', 'aaa 32', 'eee 356', 'DDD 38', 'BBB 38', 'www 99']
print(sorted(e, key=lambda x: (int(x.split()[1]), x.split()[0])))
# ['ZZZ 32', 'aaa 32', 'BBB 38', 'DDD 38', 'www 99', 'eee 356']

# Но тут сталкиваемся с проблемой регистрозависимости. И чтобы ее избежать, мы пишем .lower()
print(sorted(e, key=lambda x: (int(x.split()[1]), x.split()[0].lower())))
# ['aaa 32', 'ZZZ 32', 'BBB 38', 'DDD 38', 'www 99', 'eee 356']
