ÐŸÐ¾Ð´ Ð½Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¾Ð¹ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð° Ð½Ðµ Ð² ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ðµ Ð³Ð¾Ñ€ÑƒÑ‚Ð¸Ð½, Ð° Ð² Ñ‚Ð¾Ð¼, Ñ‡Ñ‚Ð¾ Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ
Ð³Ð¾Ñ€ÑƒÑ‚Ð¸Ð½Ñ‹ Ð¿Ñ€Ð¾Ð´Ð¾Ð»Ð¶Ð°ÑŽÑ‚ Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð»ÑÑ‚ÑŒ Ð¿Ð°Ð¼ÑÑ‚ÑŒ Ð¸ ÑƒÐ²ÐµÐ»Ð¸Ñ‡Ð¸Ð²Ð°ÑŽÑ‚ GC pressure, Ñ‡Ñ‚Ð¾ Ñ‡Ð°ÑÑ‚Ð¾ Ð¿Ñ€Ð¸Ð²Ð¾Ð´Ð¸Ñ‚
Ðº Ð½Ð°ÐºÐ¾Ð¿Ð»ÐµÐ½Ð¸ÑŽ Ð³Ð¾Ñ€ÑƒÑ‚Ð¸Ð½ Ð¸ Ð´ÐµÐ³Ñ€Ð°Ð´Ð°Ñ†Ð¸Ð¸ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹.

ðŸ‘‰ Goroutines scale much better than OS threads, but they are not free.

Goroutines
* Managed by the Go runtime, not the OS
* Start with a small stack (a few KB) that grows dynamically
* Very cheap to create and context-switch
* Designed for high-concurrency workloads

OS threads
* Managed by the operating system
* Large fixed stack (often ~1â€“8 MB)
* Expensive to create and context-switch
* Limited in number before the system degrades

Why goroutines scale better:
* Millions of goroutines can exist, while thousands of OS threads cannot
* Go scheduler multiplexes goroutines onto a small number of OS threads
* Blocking I/O does not block an OS thread

Under high load, the catch:
* Goroutines that block on I/O still consume memory
* Excessive goroutines increase GC pressure
* Goroutine buildup is a common failure mode

Important clarification:
* Goroutines are cheap, but unbounded goroutines are dangerous

One-line interview answer:
> Goroutines scale better than OS threads because theyâ€™re lightweight and scheduled
by the Go runtime, but under high load too many blocked goroutines still cause
memory and GC pressure.
