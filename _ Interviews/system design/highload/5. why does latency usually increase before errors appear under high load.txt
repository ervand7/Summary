ðŸ‘‰ Because systems fail gradually through waiting, not instantly through crashes.

What happens first:
* Requests start waiting on limited resources (CPU, DB, locks, connections)
* Queues form inside the system
* Processing still succeeds, but takes longer

Why errors donâ€™t appear immediately:
* Resources are still available, just slower
* Timeouts havenâ€™t been hit yet
* Requests are blocked, not rejected

Latency â†’ concurrency feedback loop:
* Higher latency increases in-flight requests (`RPS Ã— latency`)
* More in-flight requests consume more memory and goroutines
* This further slows the system

When errors finally appear:
* Timeouts are exceeded
* Connection pools are fully exhausted
* Memory pressure or GC pauses stall the system

Key insight:
* Latency growth is an early warning signal
* Errors are a late-stage symptom of overload

One-line interview answer:
> Latency increases first because requests start waiting on constrained resources;
errors appear later when timeouts, pool limits, or memory exhaustion are finally reached.
