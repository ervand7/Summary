Инструкция по установке гит на мак
https://netology.ru/profile/program/git-18/lessons/42367/lesson_items/193283

Фишки и возможности гит https://netology-code.github.io/guides/git-links/

```````````````````````````````````````````````
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
lesson_1: Version control system implementation

Первоначальная настройка
Настройка информации о пользователе для всех локальных репозиториев

$ git config --global user.name "имя"
Устанавливает имя, которое будет отображаться в поле автора у выполняемых вами коммитов

$ git config --global user.email "адрес электронной почты"
Устанавливает адрес электронной почты, который будет отображаться в информации о выполняемых вами коммитах

$ git config --global user.name
$ git config --global user.email
Проверить настройку учетной записи

git config --global core.editor nano
Устанавливаем дружелюбный редактор файлов, который у нас затем будет по умолчанию. Но лучше этим редактором никогда не пользоваться.

```````````````````````````````````````````````

Работа в локальном репо

$ git init
Инициализация репо. Скрытую папку можно посмотреть нажав command-shift-точка
Если вдруг случайно проинициализировал рабочий стол, то команда    rm -rf ~/.git    все исправит и вернет в исходное состояние

$ git add 
добавление
$ git add --all
добавить все
$ git add *
также добавить все
$ git add *py
добавить все файлы с расширением 'py'

$ git diff
смотрим непроиндексированные изменения
$ git diff --cached
смотрим проиндексированные изменения

$ git status
просмотр статуса изменений

$ git commit
Если так попробовать фиксировать изменения, о мы попадем в неудобный редактор.

$ git commit -a -m "My_commit"
Хороший вариант для фиксации изменений
Флаг -a(--all) говорит о том, что мы добавляем в stage все удалённые/изменённые файлы (но не новые, новые нужно добавлять отдельно).
Флаг -m "Сообщение коммита"(--message="Сообщение коммита") позволяет не открывать редактор, а указывать сообщение прямо в командной строке.
```````````````````````````````````````````````

История. Решение проблем. Справка

$ git log
показывает историю коммитов: автора, дату, текст коммита и идентификатор

$ q
выход обратно в терминал

$ git show 0325f
Пишем git show и первые 7 символов идентификатора коммита и видим какие изменения произошли

$ git rm [абсолют. путь к файлу]
Удаляет конкретный файл из рабочей директории и индексирует его удаление

$ git rm --cached [абсолют. путь к файлу]
Убирает конкретный файл из контроля версий, но физически оставляет его на своём месте

$ git rm --cached -r [абсолют. путь к папке]
удаляет из отслеживания папку

$ git commit --amend -m "Новое название коммита"
$ git push --force
Эти 2 команды выполняем, чтобы переименовать commit и запушить это изменение.

$ git revert <идентификатор коммита>
коммит с новыми изменениями, отменяющими предыдущие. Это нужно для изменения уже запушенных коммитов.
Не меняет истории - безопасный способ откатить изменения.

$ git help
справка

```````````````````````````````````````````````

.gitignore

https://github.com/github/gitignore
здесь все коммиты для различных языков программирования
файл .gitignore нужно добавлять до первого коммита

|||||||||||||| Пример файла с презентации Нетологии ||||||||||||||||
# будут игнорироваться все файлы и каталоги Thumbs.db
# вне зависимости от того, в каком каталоге они находятся
Thumbs.db

# будет игнорироваться каталог tmp
# вне зависимости от того, в каком каталоге он находится
# слэш в конце указывает, что это каталог
tmp/ 

# будет игнорироваться относительно файла .gitingore
# чаще всего относительно всего проекта
/tmp/

# будут игнорироваться все файлы и каталоги с расширением .txt
# вне зависимости от того, в каком каталоге они находятся
*.txt



|||||||||||||| Пример файла с https://support.rdb24.com/hc/ru/articles/115000463769-
%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D
0%BA%D1%81%D0%B8%D1%81%D0%B0-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0-gitignore ||||||||||||||||
# Игнор-лист файлов проекта
# Игнорировать ВСЕ файлы и директории, включая поддиректории и файлы в них
*

# ---- ФАЙЛЫ ----
# Игнорирование по типу файла, будут игнорироваться в АБСОЛЮТНО всех директориях
# Например /files/data.zip, /server.log, /uploads/users/data/info.xls
*.zip
*.log
*.pdf
*.xls
# Игнорирование файла во ВСЕХ директориях
# Например /params/db/config.php, /config.php
config.php
# Игнорирование конкретного файла ТОЛЬКО в корне проекта
# (корнём считается расположение файла .gitignore)
# Например НЕ БУДЕТ проигнорирован файл /db/config.php
/config.php
# Игнорирование конкретного файла ТОЛЬКО в указанной директории
# Например НЕ БУДЕТ проигнорирован файл /prod/params/config.php
/params/config.php

# ---- ДИРЕКТОРИИ ----
# Игнорирование всех файлов и папок ТОЛЬКО в конкретной директории(включая поддиректории и файлы в них)
# Например /images/user.jpg, /images/company/logo.png
# НЕ БУДУТ проигнорированы файлы и папки /prod/images/user.jpg
/images/*
# Игнорирование всех файлов и папок в ЛЮБЫХ директориях с указанным именем
# Например /images/user.jpg, /core/images/user.jpg
images/*
# Игнорирование ВСЕХ html-файлов в ОДНОЙ КОНКРЕТНОЙ директории(НЕ ВКЛЮЧАЯ поддиректории)
# Например /private/index.html
# НЕ БУДУТ проигнорированы файлы в /private/ivan/index.html
/private/*.html
# Игнорирование ВСЕХ html-файлов в КОНКРЕТНОЙ директории ВКЛЮЧАЯ поддиректории
# Например /private/info.html, /private/users/ivan/info.html
/private/**/*.html

# ---- РАЗНОЕ ----
# Исключение из игнорирования
# Игнорирование ВСЕХ файлов и папок внутри директории /secret,
# за исключением файла /secret/free.txt, он не будет проигнорирован
/secret/*
!/secret/free.txt
# Игнорирование файла с именем, содержащим спецсимволы
# Например !readme!.txt
\!readme!.txt
# Игнорирование всех JPG и JPEG файлов внутри директорий,
# которые начинаются на "h" и МОГУТ содержать ещё один символ после
# Например /images/h4/user.jpg, /images/h/company.jpeg
/images/h?/*.jp?g

```````````````````````````````````````````````

Редакторы кода. github

$ git clone <урл репо>
добавляем удаленный репо

заходим папку, в которой гит баш делали и 
$ cd <'абсолют. путь папки'>
переходим в папку

чтобы закачать себе любой общедоступный репо, нужно на гитхабе нажать на зеленый 'Code' и далее там скопировать ссылку и набрать в гит баше
$ git clone <ссылка>

$ git remote -v
показывает, какие удаленные репо привязаны к нашему локальному

$ git remote add origin <урл репо>
привязываем удаленный репо к локальному

$ git push -u origin master
это первичный посыл данных на гитхаб
флаг -u означает, что на удаленном репо мы создаем одноименную ветку.
Поэтому команда git push -u origin master используется только для первичной отправки данных.
Во всех остальных случаях просто git push

$ git push
второй и последующий посыл данных на гитхаб

$ git push --force
применяется в тех случаях, когда нужно отправить локальные изменения на удаленный репо,
в то время как гит еще просит спуллить изменения перед пушем, а мы не хотим этого делать.
Этой командой мы насильно отправляем изменения на удаленный репо при этом
перезатирая новым коммитом тот последний конфликтующий коммит на удаленном репо

```````````````````````````````````````````````
MARCDOWN

Посмотреть все возможности оформления, которые предлагает сервис GitHub можно по ссылке: https://guides.github.com/features/mastering-markdown/

README.md - такой файл принято использовать на гл страничке проекта на гитхабе

# Заголовок - так пишется заголовок 1-го уровня

## Заголовок - так пишется заголовок 2-го уровня

### Заголовок - так пишется заголовок 3-го уровня

**Жирный текст**

*Наклонный текст*

~~Перечеркнутый текст~~

  * Элемент списка
  * Элемент списка
    * Вложенный элемент списка
    * Вложенный элемент списка

  1.Элемент упорядоченного списка
  1.Элемент упорядоченного списка
    1. Вложенный элемент списка
    1. Вложенный элемент списка

ГИПЕРССЫЛКИ
Гиперссылки оформляются в формате
[Текст ссылки](url-адрес)
[Текст ссылки](http://localhost)

ИЗОБРАЖЕНИЯ
Изображения оформляются также, как и гиперссылки,
но перед [] ставится !,т.е.
![логотип](url-изображения)
![Bootstrap logo](https://i.imgur.com/qhtywl2.png)

КОД
Есть два варианта оформления  кода:
— Inline: код заключается в backtick'и: `строка кода`
— Block: код с подсветкой синтаксиса:
```javascript (тут прописываем назв. языка)
console.log("");
```
или другой пример:
```html
<linkrel="stylesheet"
        href="https://stackpath.bootstrapcdn.com/bootstrap/43/css/bootstrap.min.css"
        integrity="sha284-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkF0JwJ8ERdknLPMO"
        crossorigin="anonymous">
```

```````````````````````````````````````````````
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
```````````````````````````````````````````````
lesson_2: Work history and branches

branches

$ git branch <название ветки>
создаем новую ветку

$ git branch
просматриваем, какие ветки у нас есть

$ git branch -vv
просматриваем, какая локальная ветка относится к какой удаленной

$ git checkout <название ветки>
переключаемся на другую ветку

$ git checkout -b <название новой ветки>
одновременно создаем новую ветку и переключаемся на нее

когда мы делаем 
$ git push -u origin 
то гит по умолчанию отправляет на гитхаб изменения с ветки master. Чтобы отправить изменения с какой-либо 
другой ветки, нам нужно написать
$ git push -u origin <название ветки>

```````````````````````````````````````````````
merge changes

для начала, если мы сейчас не на главной ветке, то переключаемся на нее
$ git checkout master

$ git merge --no -ff <название ветки, которую хотим смерджить>
сливаем ветки. Флаг --no -ff означает, что в данном случае НЕ будет применен механизм fast forward, а в 
ветке master создается коммит, который фиксирует изменения, которые произошли при слиянии веток. 
Тут может выскочить редактор с уже заполненной информацией, ее просто нужно сохранить.

$ git merge --no -ff <название ветки, которую хотим смерджить> -m 'My_commit'
есть альтернатива, чтобы не связываться с редактором, чтобы сразу прописать коммит

$ git log --oneline --graph
гит покажет graph коммитов (диаграмму). Покажет, на каких коммитах произошло слияние

$ git log --oneline --graph --all
более полная диаграмма

$ git log --oneline
показывает только идентификатор коммита и текст коммита

```````````````````````````````````````````````
conflicts

Когда происходит конфликт при слиянии веток, то заходим с редактор кода. Он на данном этапе автоматически
показывает, где произошел конфликт. Делает он это с помощью спецсимволов, так как редактор кода уже
интегрирован с гит. Далее руками убираем все строки, на которых есть спец символы отображения конфликта.
И в итоге у нас остаются изменения и с одной ветки, и с другой. Решение конфликтов затем обязательно нужно закоммитить.

```````````````````````````````````````````````
deleting branches, tags

$ git branch -d <имя_ветки>
Удаление локальной ветки. При этом удаляемая ветка не должна быть текущей

$ git push --delete origin <название ветки>
Удаление удаленной ветки с гихаба. При этом удаляемая ветка не должна быть текущей

$ git tag –a <название тега> –m "сообщение тега"
теги нам заменяют длинные и неудобные идентификаторы коммитов. Тут мы внутри коммита создаем как бы бирку

$ git tag
посмотреть список существующих тегов

$ git show <название тега>
теперь в команде git show мы можем использовать не длинный идентификатор коммита, а название тега

$ git push --tags
по умолчанию, при git push теги на гитхаб не отправляются. Чтобы они отправились есть специальный
флаг --tags

$ git tag -d <название тега>
удаление локального тега, если еще не отправили тег на гитхаб

$ git push --delete origin <название тега>
$ git tag -d <название тега>
удаление тега на гитхабе. Сначала удаляем тег на гитхабе, а потом локально

```````````````````````````````````````````````
work with history

$ git log -p -- 'абсолют. путь к файлу'
подробный просмотр изменений с файлом

$ git log --grep 'Ini'
так мы находим историю по первым буквам названия коммита

$ git log -S 'наш кусок кода' -p
поиск по конкретному куску кода

$ git log --all
показ истории по всем веткам сразу. Нужен, так как по умолчанию команда git log ищет только в ветке master

$ git blame -- 'абсолют. путь к файлу'
просмотр авторов изменений

```````````````````````````````````````````````
device branches and HEAD

HEAD указывает на состояние файла (определенное состояние при определенном коммите или ветке). Мы можем сдвигать
указатель HEAD на то, что нам нужно с помощью
$ git checkout <идентификатор коммита>
С помощью git checkout мы можем переключиться не только на каку-то ветку, но и на определенный коммит. И
состояние файлов в нашей рабочей директории будет соответствовать тому коммиту, на который указывает HEAD.
Когда мы вручную передвигаем HEAD, гит нам говорит, что мы находимся в состоянии 'detached HEAD' (то состояние,
когда наш HEAD не указывает ни на одну ветку) и советует нам потом, после всех изменений создать ветку и залить
туда все коммиты, которые мы сделаем.

Теперь подробнее про --no -ff. 
В Git реализован механизм, который называется  fast-forward. Что он делает: если он видит при слиянии изменений,
что самым простым сценарием является просто переместить указатель на ветку на определённый коммит и не делать merge
commit, то он так и поступает. В большинстве случаев это нежелательное поведение, поэтому мы отключаем этот механизм
с помощью флага --no -ff.

```````````````````````````````````````````````
reset

git reset Позволяет нам передвигать указать, тем самым эмулируя «отмену» коммитов (сами коммиты по
факту не отменяются, мы просто перемещаем указатель). На самом деле отменить коммиты нельзя, можно лишь сделать новые.
git reset HEAD~1 # удаляет коммиты после указанного. Меняет историю - небезопасный способ откатить изменения.
Можно использовать для локальных коммитов.

Режимы:
$ git reset <mode> <commit-id>
где <mode> это:
 --hard
передвигаем указатель на определённый коммит, не сохраняя никаких изменений
 --soft
передвигаем указатель на определённый коммит, при этом предыдущие изменения сохраняются в рабочем каталоге и index'е
 --mixed (по умолчанию, можно не указывать).
передвигаем указатель на определённый коммит, при этом предыдущие изменения сохраняются в рабочем каталоге, но не в index'е

Вместо того, чтобы каждый раз указывать id-коммита, мы можем воспользоваться специальным синтаксисом:
$ git reset <mode> HEAD~<шаг_на_который_нужно_отступить_назад>
Это будет значить, что мы хотим отойти от HEAD на n-шагов.

$ git reset --hard HEAD^
удалить последний локальный незапушенный коммит
$ git reset --hard HEAD~3
удалить последние 3 локальных незапушенных коммита

$ git reset --hard <repo>/<branch>
также с помощью git reset можно удалить последний коммит на удаленной ветке
```````````````````````````````````````````````
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
```````````````````````````````````````````````
lesson_3: teamwork

remote branches

$ git push --all
отправить на гитхаб изменения со всех веток

При клонировании репозитория с удалённого сервера, Git автоматически создаёт удалённую ветку
origin/master и локальную master. Для всех остальных удалённых веток локальные ветки не создаются,
их нужно создавать с помощью команды:
$ git branch <local-branch> <origin/remote-branch>

Также можно создать локальную ветку с именем, соответствующем удалённой, а также сразу переключиться на
нее, с помощью специальной сокращённой команды:
$ git checkout --track <remote-branch>

$ git fetch <origin>
забирает изменения с удалённого сервера (если они там есть) и сдвигает указатели удалённой
ветки на нужную позицию. fetch работает с тем branch'ем, в котором вы сейчас работаете.

$ git pull позволяет выполнить двухшаговый процесс (fetch+merge) за один шаг: т.е. мы выкачиваем изменения
нужной ветки и и сразу переходите в режим слияния.
ВНИМАНИЕ! Если не получается спуллить, то можно попытаться получить все последние изменения с
удаленного репохзитория через fetch, а затем удалить последний коммит на удаленной ветке
git fetch --all
git reset --hard origin/имя_удаленной_ветки

$ git pull --rebase
Позволяет вытягивать изменения из удаленного репозитория, и те изменения, которые мы сделали в локальном
репозитории, ставить поверх вытянутых изменений

$ git stash
$ git stash apply
$ git stash save "подсказка"
$ git stash list
$ git stash pop stash@{2}
https://www.atlassian.com/ru/git/tutorials/saving-changes/git-stash

$ git rebase
https://www.atlassian.com/ru/git/tutorials/rewriting-history/git-rebase
https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History

```````````````````````````````````````````````
issues, pull requests, GitHub Pages - см. презентацию

```````````````````````````````````````````````
```````````````````````````````````````````````
```````````````````````````````````````````````
```````````````````````````````````````````````
```````````````````````````````````````````````
НАГУГЛЕННЫЕ ФИШКИ ГИТА:

 ● Объединить коммиты, которые уже запушены:
https://pingvinus.ru/git/1591
https://htmlacademy.ru/blog/boost/tools/how-to-squash-commits-and-why-it-is-needed
1) $ git rebase -i HEAD~2    тут под цифрой мы можем выбирать кол-во последних коммитов для объединений
2) оставляем "pick" под тем коммитом, К КОТОРОМУ мы хотим приклеить другой коммит, и изменяем pick на "s"
для коммита, КОТОРЫЙ прикркпляем
3) нажимаем: control+O -> Enter -> control+X
4) редактор открывается еще раз, нажимаем: control+O -> Enter -> control+X
5) $ git pull
6) редактор открывается еще раз, нажимаем: control+O -> Enter -> control+X
7) $ git push

 ● Удалить последний коммит из удаленного репозитория
https://stackoverflow.com/questions/8225125/remove-last-commit-from-remote-git-repository/8225166#answers

 ● Создать ветку от тега
https://stackoverflow.com/questions/10940981/how-to-create-a-new-branch-from-a-tag
$ git checkout -b имя_новой_ветки v1.0
ВНИМАНИЕ! Может возникнуть ошибка 'имя_тега' is not a commit and a branch 'имя_ветки' cannot be created from it
Тогда нам может помочь команда
$ pull --tag
Больше информации о tag:
https://stackoverflow.com/questions/35979642/what-is-git-tag-how-to-create-tags-how-to-checkout-git-remote-tags

 ● Обновить версию гит до последней:
$ brew install git
$ git --version
        git version 2.19.0
$ brew install git
        Warning: git 2.25.1 is already installed, it's just not linked
        You can use `brew link git` to link this version.
$ brew link git
    Linking /usr/local/Cellar/git/2.25.1...
    Error: Could not symlink bin/git
    Target /usr/local/bin/git
    already exists. You may want to remove it:
      rm '/usr/local/bin/git'

    To force the link and overwrite all conflicting files:
      brew link --overwrite git

    To list all files that would be deleted:
      brew link --overwrite --dry-run git

$ brew link --overwrite git
        Linking /usr/local/Cellar/git/2.25.1... 205 symlinks created

$ git --version
        git version 2.25.1
ВНИМАНИЕ! Тут гит может начать работать на русском языке. Чтобы он работал на английском нужно ввести
$ export LANG=en_US.UTF-8