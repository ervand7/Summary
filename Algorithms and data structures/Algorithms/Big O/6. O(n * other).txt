Сложность O(n * other) означает, что алгоритм имеет линейную зависимость от размера
входных данных (n), но также включает в себя другие операции, сложность которых линейно
зависит от размера данных. Вот некоторые примеры операций с такой сложностью:

1. **Умножение матрицы на вектор**: Умножение матрицы размера MxN на вектор размера N
может иметь сложность O(M * N), где M - количество строк в матрице, а N - количество
столбцов. Это является линейной сложностью по отношению к количеству элементов
матрицы, а также линейной сложностью относительно размера вектора.

2. **Умножение матрицы на матрицу**: Умножение двух матриц размеров MxN и NxP может
иметь сложность O(M * N * P), что является линейной зависимостью от количества
элементов в матрицах.

3. **Сложение списков**: Если алгоритм выполняет сложение (или конкатенацию) двух
списков длиной n и m соответственно, то общая сложность будет O(n * m), так как
каждый элемент первого списка должен быть объединен с каждым элементом второго списка.

4. **Итерация по двум вложенным циклам**: Если алгоритм использует два вложенных
цикла, каждый из которых выполняется n раз, то общая сложность будет O(n * n) или O(n^2).

5. **Поиск всех комбинаций в массиве**: Поиск всех возможных комбинаций элементов
в массиве длиной n может иметь сложность O(n * other), где "other" - сложность
операции создания каждой комбинации.

Эти операции имеют линейную зависимость от размера входных данных, но также
включают другие операции, которые также линейно зависят от размера данных, что
приводит к общей сложности O(n * other).