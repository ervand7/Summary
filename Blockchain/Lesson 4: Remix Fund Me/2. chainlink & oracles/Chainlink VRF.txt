Chainlink VRF (Verifiable Random Function) — это децентрализованный сервис,
предоставляемый Chainlink, который позволяет генерировать проверяемые случайные числа
на блокчейне. Этот сервис используется для создания честных и защищенных от манипуляций
случайных значений, что важно для множества приложений, таких как игры, лотереи,
распределение редких предметов и других сценариев, требующих случайности.

### Основные особенности Chainlink VRF:
1. **Проверяемая случайность**:
   - Chainlink VRF генерирует случайные числа, которые могут быть независимо проверены
   на корректность и непредвзятость.
   - Любой может проверить, что случайное число действительно сгенерировано на основе
   случайного процесса и не может быть предсказано или манипулировано.

2. **Децентрализованность**:
   - Chainlink VRF полагается на децентрализованную сеть оракулов, что предотвращает
   манипуляции со стороны единственного централизованного источника.

3. **Простота использования**:
   - Разработчики могут легко интегрировать Chainlink VRF в свои смарт-контракты с помощью
   предоставляемого интерфейса.

### Как работает Chainlink VRF:
1. **Запрос случайного числа**:
   - Смарт-контракт отправляет запрос на получение случайного числа через Chainlink VRF.

2. **Генерация случайного числа**:
   - Оракулы Chainlink принимают запрос и генерируют случайное число с использованием
   криптографических алгоритмов.

3. **Передача и проверка**:
   - Случайное число передается обратно в смарт-контракт вместе с криптографическим
   доказательством его корректности.
   - Смарт-контракт использует это доказательство для проверки, что число действительно
   случайное и не было подделано.

### Пример использования Chainlink VRF в смарт-контракте:
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

contract RandomNumberConsumer is VRFConsumerBase {
    bytes32 internal keyHash;
    uint256 internal fee;
    uint256 public randomResult;

    constructor()
        VRFConsumerBase(
            0x514910771AF9Ca656af840dff83E8264EcF986CA, // VRF Coordinator
            0x514910771AF9Ca656af840dff83E8264EcF986CA  // LINK Token
        ) {
        keyHash = 0xAA77729D3466CA35AE8D28DB1AEEDFC96DCB4030414201EED9E7635EFC6D6B41;
        fee = 0.1 * 10 ** 18; // 0.1 LINK (Varies by network)
    }

    function getRandomNumber() public returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK - fill contract with faucet");
        return requestRandomness(keyHash, fee);
    }

    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        randomResult = randomness;
    }
}
```

### Пояснение примера:
- **VRFConsumerBase**: Базовый контракт, предоставляемый Chainlink, который реализует
основные функции для работы с VRF.
- **keyHash**: Уникальный идентификатор для запроса случайного числа.
- **fee**: Плата в токенах LINK за запрос случайного числа.
- **getRandomNumber()**: Функция для запроса случайного числа.
- **fulfillRandomness()**: Функция, которая вызывается автоматически, когда случайное
число генерируется и передается обратно в смарт-контракт. Здесь `randomResult`
обновляется сгенерированным случайным числом.

Chainlink VRF обеспечивает высокий уровень безопасности и прозрачности, что делает
его идеальным решением для приложений, требующих надежной случайности на блокчейне.