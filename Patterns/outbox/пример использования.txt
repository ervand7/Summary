Ситуация: Есть сервис A, в нем цепь из 5 событий, объединенных одной sql транзакцией.
Мы хотим где-то по-середине разорвать эту цепь и использовать сервис B для
манипуляции с событием №3. У сервиса B свой BEGIN и COMMIT.

Проблема: сервис B может закоммитить изменения, в то время как в сервисе A
на последней стадии (событие №5) мы поймаем ROLLBACK. Состояние БД будет не консистентным.
А мы хотим, чтобы у нас все было как будто мы и не разрывали sql транзакцию.

Решение:
1) в БД создаем дополнительную таблицу outbox.
2) на событии №3 мы, используя общую sql транзакцию сервиса A, делаем запись
в таблицу outbox. Сюда мы записываем ровно те данные, которые мы раньше записывали в БД
через сервис B на том же шаге №3. В нее добавим еще поле State (enum: PROCESSING, FAILED,
COMPLETED). Любая первая запись будет со статусом PROCESSING.
3) в БД задаем триггер на INSERT в таблицу outbox.
4) если после события №5 получаем ROLLBACK, то ничего не происходит. Ничего никуда
не записывается, база в консистентном состоянии
5) если после события №5 получаем COMMIT, то срабатывает триггер. Мы улавливаем триггер
и на основе него запускаем функцию для записи события №3 через сервис B.
Соответственно, сервис B запишет действие №3 только когда все остальные события
будут записаны через сервис A.
6) обновляем статус записи в таблице outbox как COMPLETED.

Возможные проблемы и их решения:
сервис B может упасть и не записать событие №3. В таком случае БД будет не консистентна:
1, 2, 4, 5 события будут записаны в БД, а 3 нет. Для этого у нас будет 2 джобы:
1я - во время старта приложения, 2я - каждые n минут. Они будут проверять все записи
в таблице outbox, где State = FAILED (проставляется при fail ответе от сервиса B)
и доводить дело до конца.

Важно: сервис B должен быть идемпотентными (ON CONFLICT DO NOTHING)



