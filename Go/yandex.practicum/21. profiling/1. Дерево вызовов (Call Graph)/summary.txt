 ● go run main.go
 ● http://127.0.0.1:8080/debug/pprof/

Проанализируем CPU-профиль приложения, чтобы понять, на какие вызовы уходит
больше всего процессорного времени. Сейчас pprof показывает только текущие
данные исполнения программы. Следовательно, нужно записать статистику за
определённое время — допустим, за 30 секунд. Для этого откроем новое окно
консоли и запустим команду
 ● go tool pprof -http=":9090" -seconds=30 http://localhost:8080/debug/pprof/profile

Параметр `-http=[host]:[port]` указывает адрес сервера `pprof` для просмотра отчёта в
браузере. В данном случае откроется страница с адресом `http://localhost:9090/`.
Последний аргумент вызова — это источник профиля. Источником может быть как файл,
так и URL `http://localhost:8080/debug/pprof/profile`. Чтобы URL оставался
доступным, не останавливайте выполнение предыдущей команды `go run main.go`,
не закрывайте консоль, блокированную этой командой, а запускайте `go tool pprof`
в другом окне терминала.
Если вы всё сделали правильно, через 30 секунд в браузере откроется вкладка с деревом вызовов.

Каждый блок дерева описывает:
- имя пакета
- имя функции
- время работы функции в секундах и процентах (относительно времени сбора профиля)
без учёта внутренних вызовов
- общее время работы функции в секундах и процентах

Смотреть на общий план графа не очень удобно, тем более что вам нужна только
полезная нагрузка — функция foo. Нажмите на блок этой функции — он выделится синим.
Затем в левом верхнем углу выберите REFINE → Show from.
Вы увидите дерево вызовов с корнем в виде блока main foo:

Посмотрим внимательнее на эту часть дерева:
- Функция `foo` исполнялась за время профилирования примерно 19 секунд,
что составляет около 35% общего времени выполнения программы.
- Из этих 19 секунд 15 секунд ушло на рост слайса.
- Из 15 секунд роста слайса 13 секунд ушло на отработку функции
`memmove` пакета `runtime`.

Таким образом, больше всего времени приложение потратило на копирование памяти
при релокациях слайса.