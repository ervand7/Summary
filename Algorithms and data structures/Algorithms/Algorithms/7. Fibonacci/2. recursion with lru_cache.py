from functools import lru_cache


# С использованием кеша мы можем быстро вычислять сумму fibonacci от большего числа
# `lru_cache` в данном примере ускоряет работу, используя механизм кэширования с "Least
# Recently Used" (LRU) стратегией. Это означает, что наименее недавно использованные
# элементы будут вытеснены из кэша, чтобы освободить место для новых.
#
# В вашем конкретном случае функция `fib` рекурсивно вызывает себя для вычисления
# чисел Фибоначчи. Без кэширования она будет многократно вызываться с одними и теми
# же значениями, что приводит к избыточным вычислениям и, следовательно, замедлению
# выполнения.
#
# `lru_cache` сохраняет результаты предыдущих вызовов функции в кэше. Если функция
# вызывается с теми же аргументами, что и раньше, она просто возвращает сохраненный
# результат, минуя вычисления. Это значительно уменьшает количество повторных
# вычислений, что делает алгоритм более эффективным.
#
# В данном примере, когда `fib(498)` вызывается, `lru_cache` сохраняет результаты
# для предыдущих вызовов `fib(n)` в кэше, и если функция снова вызывается с тем же
# значением `n`, она сразу возвращает сохраненный результат, не проводя повторные
# вычисления для тех же подзадач.

# O(n) (thanks to caching with @lru_cache).
@lru_cache
def fib(n):
    if n <= 1:
        return n
    return fib(n - 1) + fib(n - 2)


print(fib(498))
