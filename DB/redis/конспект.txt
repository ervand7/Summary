туториал: https://www.youtube.com/watch?v=AimUYjKs3pQ
инструкция по установке: https://gist.github.com/tomysmile/1b8a321e7c58499ef9f9441b2faa0aa8
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
Базовые команды:
 ● redis-cli     проверяем хост и порт

 ● quit          выход

 ● set foo 42
сохраняем в ключе foo значение 42. По умолчанию все значения сохраняются как строки.
Мы можем прописывать значения без кавычек, если там 1 слово или число и нет пробелов

 ● get foo
получаем значение ключа foo

 ● exists foo
проверяем, существует ли ключ foo. Получаем в ответ <(integer) 1>. 1 означает True, 0 - False

 ● flushall
удаляем все данные из БД

 ● set bar hello ex 20
задаем значение на 20 секунд

 ● getset bar world
выводит нам предыдущее значение ключа bar ("hello") и задает новое ("world")

 ● append bar " world, well, good"
дописываем текст к уже существующему строковому значению ключа bar.
Здесь прописываем текст уже в кавычках, так как у нас уже имеются отступы

 ● keys *
возвращяет все ключи

 ● set er 5/incr er/decr er
инкрементируем и декрементируем значение ключа er на 1.
Причем внутри он все равно будет храниться как строка, а поведение у него будет как у integer. Тут есть особенность:
мы можем с помощью команды incr создать ключи и сразу присвоить ему значение 1. Например: incr counter
======================================================================================================================
======================================================================================================================
======================================================================================================================

СЛОВАРИ:
Создание аналога питоновского словаря, где у ключа может быть в качестве значения список. Здесь и далее h - сокр от hash:
 ● hset person1 name Vasya
задаем имя

 ● hset person1 age 19
задаем возраст

 ● hget person1 age
получаем возраст

 ● hgetall person1
получаем все ключи и значения

 ● hkeys person1
получаем только ключи

 ● hvals person1
получаем только значения


МНОЖЕСТВА (аналог set() из python):
 ● sadd persons vasya
 ● sadd persons petya
задаем элементы множества

 ● sadd another 'petya' 'ivan'
так тоже можно прописывать элементы множества через пробел

 ● smembers persons
 ● smembers another
смотрим, какие элементы у нас есть во множестве

 ● scard persons
проверяем кол-во элементов в множестве. card - от слова кординальный

 ● sunion persons another
объединение

 ● sdiff persons another
вычитание

 ● sinter persons another
intersection

 ● spop persons
возвращает элемент множества и удаляет его


УПОРЯДОЧЕННЫЕ МНОЖЕСТВА:
Запишем сначала данные в неправильном порядке:
 ● zadd people 1980 "vasya"
 ● zadd people 1990 "petya"
 ● zadd people 1985 "olya"
И выведем уже в правильном:
 ● zrange people 0 -1
<0 -1> означает, что выводим с 0 элемента попоследний
 ● zrange people 0 -1 withscores
<withscores> - вывод со всеми значениями



СПИСКИ:
 ● lpush mylist one
вставить значение слева

 ● rpush mylist two
вставить значение справа

 ● lrange mylist 0 -1
показать все значения

 ● lpop mylist
удалить значение слева и вывести его

 ● rpop mylist
удалить значение справа и вывести его

 ● llen mylist
узнать длину


ТРАНЗАКЦИИ:
 ● multi
объявляем начало очереди
 ● incr some
 ● decr some2
 ● (discard - принудительно выйти из очереди)
 ● exec
задаем команду "исполнить все"