### Кооперативная многозадачность — Python (с `asyncio`)
- **Как работает**: В Python, с библиотекой `asyncio`, используется **кооперативная
многозадачность**. Функции сами решают, когда "уступить" процессор. Они делают это с
помощью ключевых слов `await` или `yield`, говоря: "Сейчас я могу подождать, дай другим
задачам шанс поработать".
- **Пример**:
  ```python
  import asyncio

  async def task1():
      print("Task 1 starting")
      await asyncio.sleep(1)  # Уступаем управление
      print("Task 1 resuming")

  async def task2():
      print("Task 2 starting")
      await asyncio.sleep(1)  # Уступаем управление
      print("Task 2 resuming")

  asyncio.run(asyncio.gather(task1(), task2()))
  ```
  - **Что происходит**: Когда `await asyncio.sleep(1)` выполняется, `task1` уступает
  процессор и позволяет `task2` продолжить выполнение. Задачи сами контролируют моменты,
  когда они уступают выполнение.
- **Проблема**: Если какая-то задача "зависнет" и не вызовет `await`, другие задачи
останутся в ожидании, так как управление не будет передано дальше.

### Вытесняющая многозадачность — Go
- **Как работает**: В Go используется **вытесняющая многозадачность**, управляемая **Go
runtime**. Каждой горутине (легковесному потоку) автоматически выделяется время, и Go
runtime решает, когда "вытеснить" одну горутину и переключиться на другую.
- **Пример**:
  ```go
  package main

  import (
      "fmt"
      "time"
  )

  func task1() {
      fmt.Println("Task 1 starting")
      time.Sleep(1 * time.Second)  // Горутину можно приостановить в любой момент
      fmt.Println("Task 1 resuming")
  }

  func task2() {
      fmt.Println("Task 2 starting")
      time.Sleep(1 * time.Second)
      fmt.Println("Task 2 resuming")
  }

  func main() {
      go task1()
      go task2()
      time.Sleep(2 * time.Second)
  }
  ```
  - **Что происходит**: Горутины `task1` и `task2` запускаются одновременно, и Go
  runtime распределяет их время выполнения. Даже если одна из них "зависнет" (например,
  во время `time.Sleep`), другие горутины продолжают выполняться, потому что Go runtime
  переключает выполнение автоматически.
- **Преимущество**: Go runtime может приостановить и вытеснить любую горутину в нужный
момент, поэтому "зависшая" задача не мешает выполнению других горутин.

### Резюме
- **Python (кооперативная)**: Задачи сами решают, когда уступить выполнение, что
требует от программиста явного контроля (`await`). Если забыть сделать `await`, другие
задачи могут зависнуть.
- **Go (вытесняющая)**: Go runtime сам управляет переключением горутин, делая
систему более устойчивой и не требующей от программиста ручного управления переключениями.