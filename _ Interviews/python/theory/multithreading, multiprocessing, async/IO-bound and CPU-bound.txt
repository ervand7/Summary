Для I/O-bound задач я предпочитаю использовать multithreading, так как потоки
позволяют эффективно использовать время ожидания ввода-вывода. Для CPU-bound задач
я использую multiprocessing, который позволяет обойти GIL и использовать все
доступные ядра процессора для параллельного выполнения вычислений. Это помогает
существенно улучшить производительность приложения.


### I/O-bound задачи и Multithreading
I/O-bound задачи включают операции ввода-вывода, такие как чтение и запись файлов,
сетевые запросы, взаимодействие с базами данных и т.д. Эти задачи часто простаивают
в ожидании завершения операций ввода-вывода, и в это время процессор простаивает.

Multithreading:
- **Когда использовать**: Multithreading в Python хорошо подходит для I/O-bound задач,
потому что потоки могут работать параллельно, несмотря на наличие Global Interpreter
Lock (GIL), который ограничивает одновременное выполнение Python-кода на нескольких ядрах.
- **Преимущества**: Потоки могут переключаться при ожидании операций ввода-вывода,
что позволяет более эффективно использовать процессорное время.
- **Библиотеки**: Модуль `threading` в стандартной библиотеке Python.

**Пример**:
```python
import threading
import requests

def fetch_url(url):
    response = requests.get(url)
    print(f"Fetched {url} with status {response.status_code}")

urls = ['http://example.com', 'http://example.org', 'http://example.net']
threads = []

for url in urls:
    thread = threading.Thread(target=fetch_url, args=(url,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()
```

### CPU-bound задачи и Multiprocessing
CPU-bound задачи включают вычислительно интенсивные операции, такие как математические
вычисления, обработка изображений и видео, и другие задачи, требующие значительных
вычислительных ресурсов.

#### Multiprocessing
- **Когда использовать**: Multiprocessing подходит для CPU-bound задач, так как он
обходит GIL, создавая отдельные процессы для выполнения задач. Это позволяет
использовать несколько ядер процессора для параллельного выполнения.
- **Преимущества**: Каждый процесс имеет свой собственный интерпретатор Python и память,
что позволяет полностью использовать многопроцессорную архитектуру.
- **Библиотеки**: Модуль `multiprocessing` в стандартной библиотеке Python.

**Пример**:
```python
import multiprocessing

def compute_square(n):
    return n * n

numbers = [1, 2, 3, 4, 5]
with multiprocessing.Pool(processes=4) as pool:
    results = pool.map(compute_square, numbers)

print(results)
```

### Итог
- **Multithreading**: Лучше подходит для I/O-bound задач, так как потоки могут обрабатывать
ввод-вывод параллельно, не блокируя друг друга из-за GIL.
- **Multiprocessing**: Лучше подходит для CPU-bound задач, так как процессы могут
выполняться параллельно, используя несколько ядер процессора, обходя ограничения GIL.

### Пример на собеседовании
Если вас спросят о том, как решать I/O-bound и CPU-bound задачи в Python, вы можете
ответить так: