# # Базовый материал \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
# # Открыть файл. Используем встроенную функцию open('название файла')
# f = open('test.txt')
# print(type(f))

# # # Прочитать файл. Используем встроенную функцию .read()
# data = f.read()
# print(data)

# # Закрыть файл. Используем встроенную функцию .close()
# f.close()

# # Даже после того, как мы файл звкрыли, мы можем когда захотим прибегать к переменной data
# print(data)

# # После закрытия можем и модифицировать нашу переменную data
# data += '123123123'
# print(data)
# # Базовый материал \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/


# # Менеджер контекста \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
# # С помощью конструкции with(это и есть менеджер контекста) Pytop сам проследит за закрытием файла
# # Напишем функцию, которая будет прослеживать, открыт файлили закрыт
# def is_closed(file_):
#   if file_.closed:
#     print('Файл закрыт')
#   else:
#     print('Файл открыт')

# # f = open('test.txt') равно with open('test.txt') as f. Но тут уже все остальные действия по открытому файлу будут происходить внутри табуляции

# with open('test.txt') as f:
#  print(type(f))
#  data = f.read()
#  is_closed(f)

# is_closed(f) # И как мы видим, питон автоматически закрывает файл когда мы выходим из табулированной зоны

## А теперь убедимся, что питон еще и исправляет все допщенные нами ошибки
# try:
#   with open('test.txt') as f:
#     data = f.read()
#     is_closed(f)
#     1/0
# except ZeroDivisionError:
#   is_closed(f) # Обратите внимание, что эта строка выполняется уже после того, как в программе поисходит ошибка
# # # Менеджер контекста \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/


# # Методы объекта File для чтения\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
# # 1) .read() - чтение всего файла целиком
# # 2) .readline()- построчное чтение
# # 3) .readlines() - чтение всех строк в список

# # # 1) .read() - чтение всего файла целиком. Подробнее:
# with open('test_2.txt') as f:
#   data = f.read() # метод .read() берет все данные из файла и читает их в переменную f. Этот метод плохо работает, если файл весит очень много. И поэтому есть другие методы (см. стр. 64)
#   print(type(data))
#   print(data)
# data += '\nЕще одна строка'
# print(data)

# # 2) .readline() - построчное чтение. Подробнее.
# with open('test_2.txt') as f:
#   print(f.readline().strip())
#   print(f.readline().strip())
#   print(f.readline().strip())
#   print(f.readline().strip())
#   print(f.readline().strip())
#   print(f.readline().strip()) # У нас всего 5 строк в тектовом файле. Если мы 6-й раз вызовем print(f.readline().strip()), то питон нам выдаст пустую строку

# # 3) .readlines() - чтение всех строк в список. Подробнее.
# with open('test_2.txt') as f:
#   lines = f.readlines()
#   print(len(lines))
#   print(lines[1])
#   print(lines)

# # Python позволяет итерироваться по файлу
# with open('test_2.txt') as f:
#   for i in f: 
#     print(i.strip())
# # Методы объекта File для чтения\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/


# Запись в файл \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
# Метод .write отвечает за то, чтобы записывать данные в файл. Он принимает строку и записывает ее в файл.

# И прежде чем мы приступим к практике, мы ознакомимся с режимами работы с файлом.
# 1) Режимы работы файла:
# 'r' (read) - чтение (по-умолчанию!!!)
# 'w' (write) - запись
# 'a' (append) - запись в конец файла
# Пример: open('Имя файла', 'режим')

# 2) Режимы чтения/записи. Это не альтернативы, а дополнения к 'r', 'w' и 'a'
# 'rb' (read binary) - двоичный режим (работаем с байтами)
# 't' (text) - текстовый режим (работаем со строками, это режим по-умолчанию)

# Пробуем записать данные:
with open('test_3.txt', 'w') as f: # Добавляем после названия файла режим работы с файлом
  f.write('Привет, мир!')

# Внимание!!!!!! Мы не можем прочитать из файла, который открыт для записи. И так же мы не можем записать в файл, который открыт для чтения!!!!!!

# Пробуем прочитать файл и получаем ошибку
# with open('test_3.txt', 'w') as f:
#   print(f.read())

# Пробуем совместить 2 режима и получаем ошибку
# with open('test_3.txt', 'wr') as f:
#   # Ошибка
#   print(f.read())

# Теперь 2 раза подряд запишем данные в файл и видим, что каждый раз, когда мы открываем файл в режиме 'w' (write), мы каждый раз его открываем в режиме перезаписи. И все прежнее содержимое стирается.
# with open('test_3.txt', 'w') as f:
#   f.write('Первая строка!')
# with open('test_3.txt', 'w') as f:
#   f.write('Вторая строка!')

# И, соответственно, для того, чтобы при каждой новой записи у нас старое содержимое не исчезало, у нас существует режим 'a' (append)
# with open('test_3.txt', 'w') as f:
#   f.write('Первая строка!')
# with open('test_3.txt', 'a') as f:
#   f.write('\nОчередная строка!')

# Тперь поговорим про режимы-дополнения к 'r', 'w' и 'a'
# !!!!!!Бинарный (двоичный) режим буден нужен обязательноо когда мы будем работать с НЕ текстовыми файлами!!!!
# Обратите внимание на класс. Раньше, когда мы писали режим 'r' класс был str, а сейчас, когда мы прописываем режим 'rb' у нас <class 'bytes'>
# with open('test_3.txt', 'rb') as f:
#   data = f.read()
#   print(type(data))
#   print(data)

# Прсмотрим, что будет, если текстовый файл прочитать как байты
# with open('test_3.txt', 'rb') as f:
#   print(f.readline())
# Запись в файл \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/


# Основные ошибки при работе с файлами \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
# !!!!!!Ошибка №1: Указание неверного пути к файлу!!!!!!!!
# Пути к файлу в иерархии:
# 1. Абсолютный (от корневого каталога) - используем реже относительного.any
# Работаете с конкретной директорией?
# Используйте абсолютные пути.
# Этот путь нужен для запуска файлов, которые всегда лежат в неизменном месте.

# 2. Относительный (от текущего каталога).
# Нужен временный файл или конкретный путь не задан?
# Используйте относительные пути.
# Чаще всего придется использовать относительный путь.

# 3. Помните про ОС
# Windows - C:\Users\ddemidov\...
# Linux - /home/users/ddemidov…
# MAC - /Users/USER/Desktop/Новая папка

import os # Этот модуль отвечает за работу с путями
import time
# # Попробуем записать текущее время в файл
# with open('test_4.txt', 'w') as f:
#   f.write(f'{time.time()}') # функция time.time() возвращает текущее время в микросекундах
# with open('test_4.txt', 'r') as f:
#   print(f.read())

# Смотрим текущий путь, где мы находимся
# print(os.getcwd()) # метод .getcwd() расшифровывается как current working directory

# Теперь мы хотим построить путь к этому файлу таким образом, чтобы он всегда был одинаковым.
# Для этого мы берем текущую директорию, которую получили с помощью .getcwd(), добавляем имя файла test_4.txt с помощью метода os.path.join (это метод, который отвечает за то, чтобы строить платформо-независимые пути)
# file_path = os.path.join(os.getcwd(), 'test_4.txt')
# print(file_path)

# # А теперь открываем файл по полному пути, чтобы убедиться что это тот же самый файл
# with open(file_path, 'r') as f:
#   print(f.read())

# --------Резюмируем-------
# Методы для работы с путями
# import os - обязательно изначально импортируем
# os.getcwd() #получить абсолютный путь текущего каталога
# os.path.join(path, *paths) #построение платформоспецифичного (платформо-независимого) пути
# os.path.dirname(path) # абсолютный путь до каталога
# os.path.basename(path) # получить имя файла по полному пути

# !!!!!!!!Ошибка №2 - это вложенные with!!!!!!!
# Вложенный with дает ошибку
# with open('test_5.txt', 'w') as f:
#   f.write('Kakayatostroka')
  
#   with open('test_5.txt') as f1:
#     print(f1.read())

# # поэтому нужно выйти из файла и потом только начать его читать
# with open('test_5.txt') as f1:
#     print(f1.read())
# Основные ошибки при работе с файлами \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/


# # Кодировки \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
# with open('cp.txt', 'w+', encoding='cp1251') as f: # 'w+' - это режим создания файлов. encoding= нам задает то, в какую кодировку мы записываем данные
#   f.write('Привет, мир!')

# with open('utf.txt', 'w+', encoding='utf-8') as f:
#   f.write('Привет, мир!')

# # Проверяем, что получилось. Читаем. 
# # Тем самым видим, что у нас получаются разные наборы байт
# with open('cp.txt', 'rb') as f:
#   print('cp-1251')
#   print(f.read())

# with open('utf.txt', 'rb') as f:
#   print('\nutf-8')
#   print(f.read())

# # Если попытаемся прочитать cp.txt с encoding='cp1251' в кодировке utf-8, то получим ошибку
# with open('cp.txt', 'r', encoding='utf-8') as f:
#   print(f.read())

# # А в кодировке cp1251 все получится
# with open('cp.txt', 'r', encoding='cp1251') as f:
#   print(f.read())



