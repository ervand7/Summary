### 1ï¸âƒ£ Simplicity over cleverness

> If code needs explaining, itâ€™s probably too clever.
> Readable > smart.

---

### 2ï¸âƒ£ Single Responsibility Principle (SRP)

One module = one reason to change.
If a function has `and` in its description â€” itâ€™s doing too much.

---

### 3ï¸âƒ£ Explicit is better than implicit

Clear inputs, clear outputs, no magic side effects.
Defaults are fine â€” surprises are not.

---

### 4ï¸âƒ£ Design for change, not for perfection

Assume requirements will change.
Avoid over-engineering â€œjust in caseâ€.

---

### 5ï¸âƒ£ Fail fast and loudly

Validate early, crash early, log clearly.
Silent failures are production bugs waiting to happen.

---

### 6ï¸âƒ£ Prefer composition over inheritance

Small, composable pieces beat deep class hierarchies.

---

### 7ï¸âƒ£ Make illegal states unrepresentable

Use types, validation, and invariants to prevent bad states by design.

---

### 8ï¸âƒ£ Optimize only when there is evidence

Measure first.
Most performance â€œproblemsâ€ are imaginary.

---

### 9ï¸âƒ£ Interfaces define contracts

Depend on behavior, not implementations.
This keeps code testable and replaceable.

---

### ğŸ”Ÿ Code is read more often than itâ€™s written

Write code for the next engineer â€” often future you.
