package main

import (
	"fmt"
	"time"
)

// MyInterface При создании интерфейса компилятор создаёт в программе
// метаданные со списком методов интерфейса
type MyInterface interface {
	SayHello() string
}

// User При создании структуры компилятор создаёт в памяти структуру с
// описанием типа User, его полей
type User struct {
	Email      string
	Password   string
	LastAccess time.Time
}

// SayHello User реализует интерфейс
func (u User) SayHello() string {
	return "user with email " + u.Email
}

var user MyInterface // Объявляется переменная интерфейса — её значение пока что
// равно nil, в памяти выделяется два машинных слова под указатели tab и data

func main() {
	// Переменной присваивается конкретное значение. Проверяется, удовлетворяет ли
	// тип переменной интерфейсу.
	// При этом в tab записывается указатель на структуру itable, связывающий
	// информацию о типе User и Stringer, а в data — указатель на User{}
	user = User{Email: "qwe@rty.ru", Password: "qwerty", LastAccess: time.Now()}
	// Интересно, что связывание типа и интерфейса происходит не на этапе компиляции,
	// иначе размер программы был бы слишком большим, а на этапе выполнения.
	// Эта операция кешируется, так что выполняется всего один раз и не влияет
	// на производительность.

	// Проверяем, что в tab у нас лежит действительно тип User — и если да, то ok
	// true, а в переменную u копируется значение data.
	// Если типы не совпадают, то ok — false
	u, ok := user.(User)
	fmt.Println(u, ok)
	// {qwe@rty.ru qwerty 2023-09-06 20:39:20.020058 +0200 CEST m=+0.000081167} true
}
