# 1ï¸âƒ£ Upstream management (where traffic CAN go)

### `POST /upstreams`

ğŸ‘‰ Create an upstream pool (a logical backend service).

```json
{
  "name": "users-service",
  "discovery": {
    "type": "static",
    "targets": [
      {"address": "10.0.1.10:8080", "weight": 1},
      {"address": "10.0.1.11:8080", "weight": 2}
    ]
  },
  "lb_policy": "round_robin",
  "health_check": {
    "type": "http",
    "path": "/ready",
    "interval_ms": 1000,
    "timeout_ms": 300,
    "unhealthy_threshold": 3,
    "healthy_threshold": 2
  }
}
````

Meaning:

* name: "users-service" â€” logical name of the backend service
* targets â€” concrete service instances (IPs/ports)
* weight â€” how often an instance is picked (2 = twice as often as 1)
* lb_policy: round_robin â€” rotate requests between healthy instances
* health_check â€” periodically call /ready to decide if an instance is usable
    * fail 3 times â†’ mark unhealthy
    * succeed 2 times â†’ mark healthy again

---

### `GET /upstreams`

ğŸ‘‰ List upstream pools and their config (for ops/debugging).

---

### `PUT /upstreams/{name}`

ğŸ‘‰ Update pool settings: targets, weights, health checks, policies.

---

### `DELETE /upstreams/{name}`

ğŸ‘‰ Remove an upstream pool (usually after draining / route migration).

---

# 2ï¸âƒ£ Route management (how requests ARE matched)

### `POST /routes`

ğŸ‘‰ Add a routing rule: match request â†’ send to upstream.

```json
{
  "id": "route-users-get",
  "match": {
    "host": "api.company.com",
    "path_prefix": "/users",
    "methods": ["GET"]
  },
  "action": {
    "upstream": "users-service",
    "rewrite": {"strip_prefix": "/users"},
    "timeouts_ms": {"connect": 200, "request": 2000}
  }
}
```

Key ideas:

* `match` can use host/path/method/headers/query (as required)
* `action` chooses upstream + transforms request + sets per-route policies

---

### `GET /routes`

ğŸ‘‰ List routing table (what goes where).

---

### `DELETE /routes/{id}`

ğŸ‘‰ Remove a route rule.

---

# 3ï¸âƒ£ Policies (auth, rate limit, retries, circuit breaking)

### `POST /policies`

ğŸ‘‰ Attach policies to routes or upstreams.

```json
{
  "target": {"route_id": "route-users-get"},
  "policies": {
    "rate_limit": {"rps": 100, "burst": 50, "key": "ip"},
    "retries": {"max": 2, "retry_on": ["5xx", "connect-failure"]},
    "circuit_breaker": {"max_conns": 2000, "max_pending": 500}
  }
}
```

Notes:

* retries should be limited to safe/idempotent cases
* circuit breaker prevents upstream meltdown
* rate limit might be local-only or shared via Redis (if required)

---

# 4ï¸âƒ£ TLS & certificates (if proxy terminates TLS)

### `PUT /tls/certificates`

ğŸ‘‰ Upload or reference certificates per domain/SNI.

```json
{
  "sni": "api.company.com",
  "cert_ref": "secret://k8s/prod/api-cert"
}
```

---

# 5ï¸âƒ£ Runtime status & observability

### `GET /health`

ğŸ‘‰ Proxy instance liveness (cheap, internal).

### `GET /ready`

ğŸ‘‰ Readiness (config loaded, listeners open, can serve traffic).

### `GET /stats`

ğŸ‘‰ Live metrics snapshot (humans/monitoring).

```json
{
  "rps": 12500,
  "active_connections": 910,
  "p95_latency_ms": 21,
  "upstreams": {
    "users-service": {"p95_upstream_ms": 12, "5xx_rate": 0.002}
  }
}
```

### `GET /config/version`

ğŸ‘‰ Current applied config version (for rollouts/debug).

---

# ğŸ§  Big picture (connect everything)

* `/upstreams` â†’ defines where traffic MAY go
* `/routes`    â†’ defines how to map requests to upstreams
* `/policies`  â†’ defines what to enforce (auth/limits/retries/etc.)
* health checks â†’ decide where traffic SHOULD go
* `/stats`     â†’ tells humans how the proxy behaves
