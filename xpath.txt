основной материал законспектирован с: https://www.youtube.com/watch?v=EVGH_XxAbXQ
углубленная документация: http://citforum.ru/internet/xpath/xpath04.shtml
_______________________________________________________________________________________________

Открываем инструменты разработчика: command+alt+i (Chrome) или command+alt+u (Safari). Парсим эту страницу:
https://www.google.com/search?q=linkedin&oq=linkedin&aqs=chrome..69i57j0l2j0i20i263j0l4.4331j0j4&sourceid=chrome&ie=UTF-8

 ● Копировать xpath с помощью правой кнопкой мыши в developer tools - плохой вариант, так как там ориентир
идет на id, которые зачастую рандомно генерируются.

 ● Операции сравнения
<  логическое «меньше»
>  логическое «больше»
<= логическое «меньше либо равно»
>= логическое «больше либо равно»

 ● //                                          c этого начинается любой относительный путь

 ● //*                                         найдем абсолютно все элементы

 ● //div                                       так мы найдем все элементы с тегом div

 ● //script[@nonce]                            далее прописываем условие. Оно всегда прописывается в []. С помощью @ мы
можем обратиться к какому-нибудь конкретному атрибуту. Найдем все теги script, у которых есть атрибут nonce

 ● //div[@class='g']                           у атрибутов тегов бывает какое-то конкретное значение. Желательно все
значения атрибутов прописывать в одинарных кавычках, так как в коде весь xpath будет обрамлен, скорее всего, еще и
двойными кавычками

 ● //div[@class='g'][4]                        так как таких //div[@class='g'] у нас много, мы можем обратиться к какому-то
конкретному, прописав его индекс в отдельных []. Внимание, в xpath порядковый номер начинается с 1.

 ● //div[@class='g'][position() >= 2]          position() — возвращает позицию элемента в множестве. Так мы найдем позиции
всех элементов с тегом div, у которых атрибут class='g', у которых номер позиции больше или равен 2

 ● //div[@class='g'][position() mod 2 = 1]     mod задает остаток от деления. В данном примере будут искаться все элементы
с нечетными порядковыми номерами. Ну, соответственно, если будет написано, что mod 2 = 0, то поиск будет по четным

 ● //div[@class='g'][last()]                   обращаемся к последнему элементу с помощью [last()]

 ● //div[@class='g'][last()-1]                 обращаемся к предпоследнему элементу с помощью [last()-1]

 ● //*[text()='LinkedIn — Википедия']          с помощью text()='' мы можем найти элементы с конкретным текстом

 ● //*[contains(text(), 'LinkedI')]            если мы знаем только часть текста, которая нам интересна, мы можем искать
с помощью оператора contains. Обратите внимание, что тут уже text() и искомые данные пишутся не через '=', а через ','

 ● //h3[contains(@class, 'C20lb')]             аналогично вышеуказанному мы можем искать по части названия атрибута. В
данном случае мы ищем все теги h3, у которых в названии атрибута class содержится 'C20lb'

 ● //h3[contains(@class, "Ns") and starts-with(text(), "Linked")]     также можем использовать операторы "and" и starts-with

 ● //div[@class='g'][5]//a[@class='fl']        после того, как мы нашли нужный элемент //div[@class='g'][5], мы также можем
начать углубленный поиск. Для этого как бы заново дальше прописываем // и оставшееся условие

 ● //span[text()='Социальная сеть']/../..      с помощью /.. мы можем подняться на уровень выше, к родителю. Соответственно
с помощью /../.. мы можем подняться на 2 уровня выше, к родителю родителя

 ● //span[text()='Социальная сеть']/parent::div/parent::div      аналого примера /../..

 ● //span[text()='Социальная сеть']/../../following-sibling::div      оператор /following-sibling:: означает переход
к соседнему элементу. В данном примере мы ищем тег span (//span) у которого в тексте написано конкретно
'Социальная сеть' ([text()='Социальная сеть']), затем переходим на 2 уровня выше (/../..) и переходим на соседний
элемент div (/following-sibling::div )

 ● //div[@class='g'] | //script[@nonce]        с помощью | мы можем одновременно выбирать несколько путей

 ● //ol[@class="flex-control-nav flex-control-paging"]/child::li/following-sibling::li /child::a[contains(text(), 2)]
также мы можем использовать child, что выше показано на примере https://www.python.org/






