Аллокация — это выделение памяти в heap под новый объект, за которым потом
должен следить GC. Новая горутина стартует примерно с ~2 KB стека.
Память под стек не в heap, GC лишь сканирует его, но не управляет им напрямую


* Создают ли горутины нагрузку на GC?
  → Да, через алокации, а не через их количество само по себе.

* GC следит за горутинами?
  → GC сканирует стеки горутин (они маленькие и растут динамически).

* Много горутин = медленный GC?
  → Только если они много аллоцируют или держат ссылки на объекты.

* Как GC останавливает горутины?
  → STW-паузы короткие, GC в Go в основном конкурентный.

* Горутины и утечки памяти?
  → GC не очистит память, если горутина держит ссылку (канал, closure).

* Как уменьшить влияние GC?
  → Меньше аллокаций, reuse объектов, `sync.Pool`.

Одна фраза для ответа:
> GC в Go сканирует стеки горутин, а нагрузка на него определяется объёмом аллокаций
и живых объектов, а не количеством горутин.
