Основная логика GC реализована тут: src/runtime/mgc.go

GC реализован с помощью алгоритма Mark and Sweep
Mark - фаза разметки
    - реализована с помощью трехцветного алгоритма. Он конкурентный и выполняется
    конкурентно с основной программой.
        - все данные в куче представляются как граф связанных объектов
        - каждый объект может быть окрашен в один из трех цветов: белый, серый, черный
        - обходятся корневые объекты: глобальные переменные
        - далее эти элементы проверяются на наличие указателей на них: если указатель есть,
        они помечаются черным, если нет - белым. Серые - это те, на которые есть указатель,
        но пока еще не понятно откуда. В итоге серые и черные остаются, а белые удаляются.

Sweep - фаза очистки

 - GC можно вызывать вручную с помощью с помощью функции runtime.GC()
 - на работу GC выделяется 25% от объема CPU, которое использует приложение

---------------------------------------------------------------------------
Подробнее про Этап Mark:
Mark можно поделить на 3 этапа работы. Два из этих этапов создают задержки
Stop The World (STW), а другая фаза создает задержки, которые замедляют пропускную
способность приложения. GC делает все возможное, чтобы сохранить задержки
STW менее 100 микросекунд для каждого GC.

Эти 3 этапа:
    - Mark Setup - STW (Stop The World)
    - Marking - Concurrent
    - Mark Termination

====== Mark Setup - STW (Stop The World) ======
При запуске GC первое действие, которое должно быть выполнено - это включение
барьера записи (Write Barrier). Цель барьера записи заключается в том, чтобы позволить
GC поддерживать целостность данных в куче во время сбора, так как горутины
коллектора и приложения будут работать одновременно.

На рисунке 1 показаны 4 приложения Goroutines, запущенные до начала коллекции.
Каждая из этих четырех горутин должна быть остановлена. Единственный способ сделать
это - наблюдать и ждать, пока каждая горутина войдет в безопасное место.
Безопасная точка - это место, когда горутина не находится в середине чтения
или записи памяти.

====== Marking - Concurrent ======
Как только Write Barrier включен, GC начинает с фазы маркировки. Первое, что
делает GC - берет для себя 25% доступной емкости CPU. GC использует горутины
для выполнения работы по сбору и нуждается в тех же P и M, что и приложение.
Это означает, что для нашей 4-поточной программы Go весь P будет посвящен
работе по сбору (рисунок 2). Это как раз тот момент, где мы говорим, что
на работу GC выделяется 25% от объема CPU, которое использует приложение


Что делать, если во время коллекции будет установлено, что Goroutine, посвященный GC
на P1, не завершит работу по маркировке до того, как использование памяти кучи
достигнет своего целевого предела, установленного коллекцией перед началом?
В этом случае новые аллокации должны быть замедлены, и особенно из этих горутин.
Если GC определит, что ему нужно замедлить аллокации, он задействует горутины приложения
для оказания помощи в работе по маркированию. Этот процесс называется Mark Assist.
Время, в течение которого любая горутина приложения будет помещена в Mark Assist
пропорционально объему данных, которые оно добавляет в кучу памяти. Одним из
положительных побочных эффектов Mark Assist является то, что он помогает быстрее
завершить сбор.
На рисунке 3 показано, как приложение Goroutine, работающее на P3, теперь выполняет
Mark Assist и помогает в сборе.

Одной из целей GC является устранение необходимости в Mark Assists. Если какая-либо
данная коллекция в конечном итоге потребует большого количества Mark Assist,
сборщик может начать следующую сборку мусора раньше. Это делается в попытке
уменьшить количество Mark Assist, которое потребуется для следующей коллекции.

====== Mark Termination ======
Write Barrier отключается, выполняются различные задачи очистки и рассчитывается
следующая цель сбора. Все горутины останавливаются (рисунок 4).
После завершения коллекции каждый P может быть снова использован приложением
Goroutines, и приложение вернется на полную мощность (рисунок 5).
