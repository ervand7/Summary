 https://www.youtube.com/watch?v=I18TNwZ2Nqg&t=1026s

 ● docker pull tomcat
скачиваем image "tomcat" через терминал; также можно все образы посмотреть в GUI тут:
https://hub.docker.com/search?q=&type=image

 ● docker run -it -p 1234:8080 tomcat
по умолчанию у докера внутри порт 8080;
-it - это интерактивный режим;
Этой командой мы говорим докеру, чтобы он запустил (run) в интерактивном режиме (-it)
образ (tomcat), при этом получив доступ к порту докера (8080) через кастомный (1234)
порт (-p);
Первый будет на нашей машине, второй - порт внутри docker-контейнера


 ● docker run -d -p 1235:8080 tomcat
аргумент -d (demon) означает, что наш контейнер будет работать в фоновом режиме;
попробуем подключиться через другой порт
 ● docker run -d -p 1236:8080 tomcat
запускаем параллельно еще один контейнер


 ● docker run -d -p 1237:80 nginx
запускаем без предварительного скачивания образ nginx; докер увидит, что локально этого образа у нас нет
и пойдет в докерхаб и оттуда скачает его и запустит; nginx поднимается только на 80 порте


 ● docker images
смотрим, какие образы у нас есть
 ● docker rmi hello-world
попробуем удалить образ "hello-world" с помощью команды rmi (remove image)
и у нас не получается, так как у нас есть контейнер, который использует этот image
поэтому нам нужно стереть контейнер


 ● docker ps -a
смотрим, какие контейнеры есть
 ● docker rm 304d21612f31
удаляем контейнер по CONTAINER ID
 ● docker rmi hello-world
удаляем образ
______________________________________________________________________________________

Теперь мы хотим из нашего Dockerfile сделать image.

 ● docker build -t denis .
Команда <docker build> создает образы. Флаг -t означает тег, как мы назовем наш новый образ. Назовем его
<denis>. Следующим параметром мы должны указать исходник, то есть путь, откуда мы все будем собирать.
В данном случае ставим "." - что обозначает текущую директорию.
Что тут произошло? Мы видим загрузку базового образа, который мы указали в Dockerfile (FROM ubuntu:16.04). Докер
не нашел такой образ локально, он пошел в Docker hub, нашел там такой образ и начал его скачивать


 ● docker run -d -p 7777:80 denis
запускаем наш собственный образ как demon


 ● docker tag denis:latest denis:copy
по умолчанию всем имейджам присваивается тег latest; а этой командой мы создаем копию образа,
и у этой копии теперь будет тег "copy"

______________________________________________________________________________________

Теперь попробуем изменить содержимое нашего Dockerfile без текстого редактора
 ● docker exec -it айди_контейнера /bin/bash
этим самым мы сделали мини log in на нашу виртуальную машину
 ● pwd
проверим текущую директорию
cd /var/www/html/
 ● cd /var/www/html/
перейдем в папку, которую мы создавали в Dockerfile
 ● ll
посмотрим содержимое
 ● echo "Version v2" >> index.html
в режиме дозаписи добавляем новые данные в index.html
 ● cat index.html
смотрим содержимое файла index.html
 ● обновляем страницу в браузере (http://192.168.1.100:7777) и видим, что туда добавилась новая запись
 ● exit
выходим обратно


 ● docker commit айди_коммита denis:v2
меняем текущий тег на "v2"

______________________________________________________________________________________
СЕРИЛИЗАЦИЯ И ДЕСЕРИАЛИЗАЦИЯ:
 ● docker save image:tag > имя_архива.tar
сохраняем образ в архив в текущую директорию

 ● docker load -i имя_архива.tar
загрузить image с архива


______________________________________________________________________________________
Kill and Delete Containers and Images:
 ● docker rm -f $(docker ps -aq)        # Delete all Containers
 ● docker rmi -f $(docker images -q)    # Delete all Images


______________________________________________________________________________________
Import/Export Docker Image to AWS ECR:
 ● docker build -t denis:v1 .
 ● aws ecr get-login --no-include-email --region=ca-central-1
 ● docker tag  denis:v1  12345678.dkr.ecr.ca-central-1.amazonaws.com/myrepo:latest
 ● docker push 12345678.dkr.ecr.ca-central-1.amazonaws.com/myrepo:lastest
 ● docker pull 12345678.dkr.ecr.ca-central-1.amazonaws.com/myrepo:latest