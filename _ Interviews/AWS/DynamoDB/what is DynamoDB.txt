DynamoDB â€” what you must know:

ðŸ‘‰ DynamoDB is query-driven, not schema-driven.

* NoSQL, key-value + wide-column store (not relational, no joins)
* Primary key design is everything
 - Partition key = decides how data is spread across servers
   â†’ bad choice = hot partition (physical shard), no scalability
 - Sort key = decides how you can query data inside one partition
   â†’ ranges, ordering, filtering
* Access patterns first, schema second (design for queries, not normalization)
* Strong vs eventual consistency (default is eventual)
* Indexes
 - GSI â†’ lets you query by a different partition key
* Throughput & scaling

  * On-demand vs provisioned
  * Hot partitions = your main enemy
* Query vs Scan

  * Query = fast, cheap
  * Scan = slow, expensive (avoid in prod)
* Transactions exist, but limited and costly
* TTL for automatic item expiration
* Conditional writes = optimistic locking / idempotency
* Pricing model: pay per read/write + storage
* Typical use cases: high-scale APIs, session storage, counters, event/state storage
* Not good for: ad-hoc analytics, complex relations, joins
